#include"Kruskal Algorithm Graph.cpp"
#include<algorithm>
using namespace std;
#define MaxSize 100
typedef struct node{
	int data;		
    int rank;		
    int parent;	
} UFSTree; // check the node type of the set tree.
void MAKE_SET(UFSTree t[],int n)	//Initialize and find the tree
{  for (int i=0;i<n;i++)		//The vertex number is 0~(n-1)
   {  t[i].rank=0;				//The rank is initialized to 0
      t[i].parent=i;			//Parents point to themselves
   }
}
int FIND_SET(UFSTree t[],int x)	 // this will find the number of the collection in the subtree where x is located
{  if (x!=t[x].parent)		//  If the parents are not yourself
     return(FIND_SET(t,t[x].parent));	//Recursively find x among the parents
   else
     return(x);			//If the parents are self, return x
}
void UNION(UFSTree t[],int x,int y)	//Merge the subtree where x and y are located
{  x=FIND_SET(t,x);
   y=FIND_SET(t,y);
   if (t[x].rank>t[y].rank)	//The rank of the x node is greater than the rank of the y node
	t[y].parent=x;			
   else				
   {  t[x].parent=y;			
      if (t[x].rank==t[y].rank)	
         t[y].rank++;			
   }
}
struct Edge{
	int u;		
    int v;	
    int w;
    bool operator<(const Edge &e) const {
	return w<e.w;
	}
};

void Kruskal(MGraph g)	// Kruskal algorithm
{  int i,j,k,u1,v1,sn1,sn2;
   UFSTree t[MaxSize];
   Edge E[MaxSize];
   k=0;
   for (i=0;i<g.n;i++) //The edge set E generated by the lower triangular part of g
     for (j=0;j<i;j++)
	if (g.edges[i][j]!=0 && g.edges[i][j]!=INF)
	{   E[k].u=i;E[k].v=j;E[k].w=g.edges[i][j];
	    k++;
	}
   sort(E,E+k);		//Call STL's sort() algorithm to sort in ascending order by w
   MAKE_SET(t,g.n);		
   k=1;				
   j=0;	
while (k<g.n)		//Loop when the number of generated edges is less than n
   {  u1=E[j].u;
      v1=E[j].v;		
      sn1=FIND_SET(t,u1);
      sn2=FIND_SET(t,v1);	
      if (sn1!=sn2)		
		//Adding this edge will not form a loop, and output it as an edge of the minimum spanning tree
      {  printf("  (%d,%d):%d\n",u1,v1,E[j].w);
         k++;			
         UNION(t,u1,v1);	//Merge the two vertices u1 and v1.
      }
      j++;		
   }
}
int main()
{
	MGraph g;
	int A[][MAXV]={
	    {  0,  6,  1,  5,INF,INF},
	    {  6,  0,  5,INF,  3,INF},
	    {  1,  5,  0,  5,  6,  4},
	    {  5,INF,  5,  0,INF,  2},
	    {INF,  3,  6,INF,  0,  6},
	    {INF,INF,  4,  2,  6,  0}};
	int n=6,e=10;
	CreateMat(g,A,n,e);
	printf("adjency matrix of the graph:\n");
	DispMat(g);
	printf("results of kruscal algorithm:\n");
	Kruskal(g);
}





